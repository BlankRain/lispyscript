<!DOCTYPE html>
<html lang="en">
  
  <head>
    <title>LispyScript Docs</title>
    <link href="../bootstrap/css/bootstrap.css" rel="stylesheet"/>
    <style type="text/css">
      body {
        padding-top: 60px;
      }
    </style>
    <link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet"/>
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src='http://html5shim.googlecode.com/svn/trunk/html5.js'></script>
    <![endif]-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-8490402-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="#">LispyScript!</a>
          <div class="nav-collapse">
            <ul class='nav'>
              <li>
                <a href='../'>Home</a>
              </li>
              <li>
                <a href='../tryit'>Try It!</a>
              </li>
              <li class='active'>
                <a href='#'>Docs</a>
              </li>
              <li>
                <a href='http://lispyscript.blogspot.in/'>Blog</a>
              </li>
              <li>
                <a href='https://github.com/santoshrajan/lispyscript'>View Source</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class='container'>
      <div class='page-header'>
        <h1><img src="../images/logo32.png"/> LispyScript Docs</h1>
        <p>A javascript With Lispy Syntax And Macros!</p>
      </div>
      <div class='row'>
        <div class='span4'>
          <ul class="nav nav-list">
            <li class="active">
              <a href="#macros">Macros</a>
            </li>
            <li>
              <a href="#templates">Templates</a>
            </li>
            <li>
              <a href="#operators">Operators</a>
            </li>
            <li>
              <a href="#looping">Iteration and Looping</a>
            </li>
             <li>
              <a href="#statements">Statements</a>
            </li>
             <li>
              <a href="#sequence">Callback Sequence</a>
            </li>
             <li>
              <a href="#testing">Testing</a>
            </li>
             <li>
              <a href="#browser">Browser Compatibility</a>
            </li>
          </ul>        
        </div>
        <div class='span8'>
        
<h2>Macros</h2>
<h4>(macro name (arguments expression) (template expression))</h4>
<p>LispyScript is not a dialect of Lisp. There is no list processing in LispyScript . LispyScript
is Javascript using a Lispy syntax (a tree syntax). This is so that we can manipulate the syntax tree
while compiling, in order to support macros.</p>
<p>You can define a macro.</p>
<pre>(macro array? (obj)
  (= (Object.prototype.toString.call ~obj) &quot;[object Array]&quot;))
</pre>

<p>The 'array?' conditional is defined as a macro in LispyScript. The 'macro' expression takes a name as
its second element, a parameters list in the third element, and the fourth element is the template
to which the macro will expand.</p>
<p>Now let us create a Lisp like 'let' macro in LispyScript.</p>
<pre>(macro let (names vals rest...)
  ((function ~names ~rest...) ~@vals))

(let (name email tel) (&quot;John&quot; &quot;john@example.org&quot; &quot;555-555-5555&quot;)
  (console.log name)
  (console.log email)
  (console.log tel))
</pre>

<p>The 'let' macro creates lexically scoped variables with initial values. It does this by creating
an anonymous function whose argument names are the required variable names, sets the variables to
their initial values by calling the function immediately with the values. The macro also wraps the
required code inside the function.</p>
<p>Now lets look at the call to the 'let' macro. 'names' will correspond to '(name email tel)'. 'rest...'
corresponds to '(console.log name) (console.log email) (console.log tel)', which is the rest of the
expressions after vals. We want to dereference these values in the macro template, and we do that
with '~names', '~rest...'. However 'vals' corresponds to ("John" "john@example.org" "555-555-5555").
But thats not the way we want to dereference it. We need to dereference it without the parenthesis.
For that we use '~@vals'.</p>
<p>We don't really need 'let' in LispyScript. We have 'var'. But if you need it, you can extend LispyScript
by adding this macro to your code. Thats the power of macros. You can
extend the language itself or create your own domain specific language.</p>

<a name="templates"></a>
<h2 style="padding-top:40px">Templates</h2>
<h4>(template name (argument expression) (string expressions) ... )</h4>
<p>template takes a name and a list of arguments to be passed to the template as the second argument. The rest of the arguments are string expressions that make up the template. Template returns a compiled template function with the given name which you must call with the arguments to expand the template.</p>
<h4>(template-repeat (array expression) (string expressions) ... )</h4>
<p>template-repeat takes an array as its first argument and the rest are string expressions that form the template. The template is iterated over for every element of the array and the combined expanded template is returned. Within the template you can access the current element as 'elem' and the current index as 'index'.
Note that while 'template' returns a compiled template, 'template-repeat' returns the actual expanded string.</p>
<h4>(template-repeat-key (object expression) (string expressions) ... )</h4>
<p>template-repeat-key takes an object as its first argument and the rest are string expressions that form the template. The template is iterated over for every key value pair of the object and the combined expanded template is returned. Within the template you can access the current value as 'value' and the current key as 'key'.
Note that while 'template' returns a compiled template, 'template-repeat-key' returns the actual expanded string.</p>
<h4>HTML5 Templates</h4>
<p>Lispysript has a tree structure just like html, we can write html in our
templates in a Lispy manner. By including the 'html.ls' module you write
HTML Templates like below.</p>
<pre><code class="lisp">
(include &quot;html.ls&quot;)

(template page (title links)
  (html {lang:&quot;en&quot;}
    (head
      (title title)
      (script {type:&quot;text/javascript&quot;, src:&quot;js/test.js&quot;}))
    (body
      (div {class:&quot;navigation&quot;}
        (ul
          (template-repeat links 
            (li &quot;&lt;a href=\&quot;&quot; elem.href &quot;\&quot;&gt;&quot; elem.text &quot;&lt;/a&gt;&quot;))))
      (h1 &quot;HTML Templates&quot;)
      (p &quot;Welcome to LispyScript HTML templates!&quot;))))

(console.log
  (page
    &quot;My Home Page&quot;
    [{href:&quot;/about&quot;, text:&quot;About&quot;},
     {href:&quot;/products&quot;, text:&quot;Products&quot;},
     {href:&quot;/contact&quot;, text:&quot;Contact&quot;}]))

And below you can see the beautified html output.

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;title&gt;My Home Page&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;navigation&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/products&quot;&gt;Products&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/contact&quot;&gt;Contact&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h1&gt;HTML Templates&lt;/h1&gt;
        &lt;p&gt;Welcome to LispyScript HTML templates!&lt;/p&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<a name="operators"></a>
<h2 style="padding-top:40px">Operators</h2>
<pre>undefined?, null?, true?, false?, zero?, boolean?, number?, string?, object?, array?, function?,
=, !=, !, &gt;, &lt;, &lt;=, &gt;=, +, -, *, /, %, &amp;&amp;, ||.
</pre>
<a name="statements"></a>
<p>Note: <code>=</code> and <code>!=</code> work like <code>===</code> and <code>!==</code> in Javascript.</p>

<a name="looping"></a>

<h2 style="padding-top:40px">Iteration & Looping</h2>

<h4>(loop (arguments) (initial values) (expression1) (expression2) ...)</h4>
<p>The loop - recur construct is a tail call optimised looping expression. It creates a binding for
a set of arguments with a set of initial values. A recusion point is set by using a recur expression 
which passes control back to the top of the loop with a new set of bindings for the arguments.</p>
<pre>
(loop (result x) ([] 5)
  (if (= 0 x)
    result
    (do
      (result.push x)
      (recur result --x))))
</pre>
<p>The example above will return a countdown array starting from 5 "[5, 4, 3, 2, 1]"</p>
<p>Read more about loop recur and tail call optimization <a href="http://lispyscript.blogspot.in/2012/09/loop-recur-and-tail-call-optimization.html">here.</a></p>

<h4>(each array (iterator) [(context)])</h4>
<p>each takes an array, an iterator function and an optional context. The iterator is called for each
element of the array with element value, index, array. If context is provided then "this" inside the 
iterator function will be the context object.</p>
<pre>(each [1, 2, 3]
  (function (elem index list)
    (console.log elem)))
</pre>

<h4>(eachKey object (iterator) [context])</h4>
<p>eachKey iterates over a map (object) and calls the iterator with value, key, object respectively.</p>

<h4>(reduce array (iterator) [initial])</h4>
<p>reduce takes an array, an iterator function and an optional initial value. The iterator is called
with the following paramaters, previous value returned by the last call to iterator, current value of array element, array index, and array. First time around the initial value is used for previous value. If no initial value is given, the previous value is set to the first element of the array and the iteration starts from the second element. The last value returned by the iterator is returned by reduce.</p>
<pre>(reduce [1,2,3,4]
  (function (accum val i list)
    (+ accum val))))
</pre>
<p>The above call to reduce will return 10.</p>

<h4>(map array (iterator) [(context)])</h4>
<p>map takes an array, an iterator function and an optional context. The iterator is called for each
element of the array with element value, index, array. The returned value from the iterator for each call
is pushed into a new array. map returns the new array. If context is provided then "this" inside the 
iterator function will be the context object.</p>

<h2 style="padding-top:40px">LispyScript Statements</h2>

<h4>(str (string expression) ...)</h4>
<p>Adds up all the strings.</p>
<pre>(var title &quot;My Home Page&quot;)
(console.log
  (str &quot;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;&quot; title &quot;&lt;/title&gt;
&lt;/head&gt;
&lt;body class=\&quot;test\&quot;&gt;
Hello World
&lt;/body&gt;
&lt;/html&gt;&quot;))
</pre>
<p>In LispyScript double quoted strings are multiline strings. As you can see above they span multiple lines.
If you need a double quote inside the string, escape it with \".</p>

<h4>(array elem1 elem2 ....)</h4>
<p>Create a Javascript Array.</p>
<pre>(array 1 2 3 4)
</pre>
<p>You can also create an array using the Javascript literal notation like [1, 2, 3, 4] however there is a difference.
The literal notation is evaluated in the Javascript context, and will work in most cases except when you want some
LispyScript code evaluated, like when one of the elements is a LispyScript anonymous function. And unlike Javascript
"new Array" a single integer passed will still create a proper array with the int as the first element.</p>

<h4>(object key1 val1 key2 val2 ....)</h4>
<p>Create a Javascript Object.</p>
<pre>(object "a" 1 "b" 2 "c" 3) => {a: 1, b:2, c:3}
</pre>

<h4>(new Classname arg1 arg2 ....)</h4>
<p>Instantiate a new Javascript Object.</p>
<pre>(new Date)
(new Date "October 13, 1975 11:13:00")
</pre>

<h4>(if (condition) (if true expression) (if false expression))</h4>
<p>If takes a conditional expression and evaluates the true expression if the condition is true, or the false
expression otherwise.</p>

<h4>(do (expression1) (expression2) ...)</h4>
<p>The do statement evaluates a set of expressions passed as it arguments.</p>

<h4>(when (condition) (expression1) (expression2) ...)</h4>
<p>The when statement evaluates a set of expressions passed as it arguments when the condition is true.</p>

<h4>(unless (condition) (expression1) (expression2) ...)</h4>
<p>The unless statement evaluates a set of expressions passed as it arguments when the condition is false.</p>

<h4>(function (arguments expression) (expression1) (expression2) ... )</h4>
<p>Creates an anonymous function.</p>

<h4>(try (expression1) (expression2) ... (catch function))</h4>
<p>Try takes a set of expressions and evaluates them. The last expression must be a function, that
will be called in case an exception is thrown. The function is called with the error object.</p>
<pre>(var fs (require 'fs'))
(var outfile &quot;text.txt&quot;)
(try
  (fs.writeFileSync outfile &quot;Hello World&quot;)
  (function (err)
    (console.log (+ &quot;Cannot write file &quot; outfile)
    (process.exit 1)))
</pre>
<h4>(include "string filename")</h4>
<p>Includes a file to be compiled with this compilation unit. It will also search the 'includes' folder for Lispyscript modules like 'html.ls'.</p>
<h4>(throw (expression))</h4>
<p>Will throw an error. (expression) can be string or object or an expression</p>
<h4>Comments</h4>
<a name="sequence"></a>
<p>Comments in LispyScript start with a <code>;</code> and span the rest of the line.</p>

<h2 style="padding-top:40px">Callback Sequence</h2>
<p>LispyScript allows you to avoid writing nested callbacks, by a callback sequence feature. You write your callbacks
in a series (sequence). All the functions in the series are exposed to a functions called "next". Calling "next"
returns the next callback in the sequence. So just pass the return value of next, when you call a callback.
<a name="testing"></a>
You can see an example with some notes on usage <a href="https://gist.github.com/3715526">here</a>.
</p>

<h2 style="padding-top:40px">Testing</h2>
<p>LispyScript comes with some built in testing features to let you test your code while developing. However if
you find that the features offered in the built in tests are not enough, you can use any of the javascript
test frameworks available.</p>
<h4>(assert (expression) "string message")</h4>
<p>The expression must evaluate to "true" and not something truthy, and will return the message
with "Passed " or "Failed " added to your message. </p>
<h4>(testGroup name (assert1) (assert2) ...)</h4>
<p>Create test groups by calling the testGroup expression. It takes a name and one or more asserts. It creates a
testGroup which is invoked by the testRunner.</p>
<h4>(testRunner groupname "Desription")</h4>
<p>Call testRunner to invoke your test group. Pass it the name of the test group and a string description
<a name="browser"></a>
which will be shown at the top of your test results. It returns the test results as a string.</p>
         
<h2 style="padding-top:40px">Browser Compatibility</h2>
<p>The compiled Javascript code is compatible with all modern browsers.</p>
<p>However since Lispyscript allows you to call Javascript functions directly from LispyScript,
you need to guard against calling non standard native functions. eg. If you call the Javascript "forEach" from
LispyScript, this will not work in IE8. So instead use LispyScript "each" instead.</p>
<p>You can also run LispyScript directly in your browser. Thats how the LispyScript tryit page works.
However this is not recommended, because compiling your LispyScript and loading the compiled Javascript will
always be faster.</p>

        </div>
      </div>
      <footer class="footer" style="margin-top: 45px; padding: 35px 0 36px;border-top: 1px solid #e5e5e5;">
        <p class="pull-right"><a href="#">Back to top</a></p>
        <p>Code licensed under the <a href="https://github.com/santoshrajan/lispyscript/blob/master/LICENSE" target="_blank">MIT License</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
        <p>Logo Icon from <a href="http://www.designcontest.com">DesignContest</a>, licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
      </footer>
    </div>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
    type="text/javascript"></script>
    <script type="text/javascript" src="../bootstrap/js/bootstrap.js"></script>
  </body>

</html>
