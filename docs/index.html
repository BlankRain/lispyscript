<!DOCTYPE html>
<html lang="en">
  
  <head>
    <title>LispyScript Docs</title>
    <link href="../bootstrap/css/bootstrap.css" rel="stylesheet"/>
    <style type="text/css">
      body {
        padding-top: 60px;
      }
      h4 {
        padding-top: 20px;
        padding-bottom: 10px;
      }
    </style>
    <link href="../bootstrap/css/bootstrap-responsive.css" rel="stylesheet"/>
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src='http://html5shim.googlecode.com/svn/trunk/html5.js'></script>
    <![endif]-->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-8490402-6']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  
  <body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="#">LispyScript!</a>
          <div class="nav-collapse">
            <ul class='nav'>
              <li>
                <a href='../'>Home</a>
              </li>
              <li>
                <a href='../tryit'>Try It!</a>
              </li>
              <li class='active'>
                <a href='#'>Docs</a>
              </li>
              <li>
                <a href='http://lispyscript.blogspot.in/'>Blog</a>
              </li>
              <li>
                <a href='https://github.com/santoshrajan/lispyscript'>View Source</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class='container'>
      <div class='page-header'>
        <h1><img src="../images/logo32.png"/> LispyScript Docs</h1>
        <p>A javascript With Lispy Syntax And Macros!</p>
      </div>
      <div class='row'>

        <div class='span4'>
          <ul class="nav nav-list">
            <li>
              <a href="#operators">Operators</a>
            </li>
            <li>
              <a href="#statements">Statements</a>
            </li>
            <li>
              <a href="#looping">Iteration and Looping</a>
            </li>
            <li>
              <a href="#macros">Macros</a>
            </li>
            <li>
              <a href="#modules">Modules</a>
            </li>
            <li>
              <a href="#monads">Monads</a>
            </li>
            <li>
              <a href="#templates">Templates</a>
            </li>
            <li>
              <a href="#sequence">Callback Sequence</a>
            </li>
            <li>
              <a href="#testing">Testing</a>
            </li>
            <li>
              <a href="#browserrunning">Running in Browser</a>
            </li>
            <li>
              <a href="#browser">Browser Compatibility</a>
            </li>
            <li>
              <a href="#guidelines">Programming Guidelines</a>
            </li>
          </ul> 
          <div class="well" style="margin-top:40px">
            <p><a href="https://groups.google.com/forum/#!forum/lispyscript">Forum</a></p>
            <p><a href="https://github.com/santoshrajan/lispyscript/issues">Report Issues</a></p>
            <h4>Tutorials</h4>
            <p><a href="http://dailyjs.com/2012/09/21/lispyscript/">Introduction</a></p>
            <p><a href="http://dailyjs.com/2012/10/05/lispyscript-macros/">Writing LispyScript Macros</a></p>
            <p><a href="http://lispyscript.blogspot.in/2012/09/loop-recur-and-tail-call-optimization.html">Loop-Recur and Tail Call</a></p>
            <h4>Examples</h4>
            <p><a href="https://gist.github.com/3321591">Templates</a></p>
            <p><a href="https://gist.github.com/3715526">Callback sequence</a></p>
            <p><a class='btn btn-primary' href='https://twitter.com/LispyScript'>Follow @LispyScript</a></p>
          </div>       
        </div>


        <div class='span8'>


<a name="operators"></a>
<h2 style="padding-top:40px">Operators</h2>

<pre>undefined?, null?, true?, false?, zero?, boolean?, number?,
string?, object?, array?, function?,
=, !=, !, &gt;, &lt;, &lt;=, &gt;=, +, -, *, /, %, &amp;&amp;, ||.
</pre>
<p>Note: <code>=</code> and <code>!=</code> work like <code>===</code> and <code>!==</code> in Javascript.</p>


<a name="statements"></a>
<h2 style="padding-top:40px">LispyScript Statements</h2>

<h4>(-> (function expression) (.key1 args1 ...) (.key2 args2 ...) ...)</h4>
<p>"->" is the method chaining macro.</p>
<p>Consider the JavaScript below.</p>
<pre>$("#xyz").required().alphanum().min(3).max(30).with("email");</pre>
<p>The same JavaScript in LispyScript using the method chaining macro.</p>
<pre>(-> ($ "#xyz") (.required) (.alphanum) (.min 3) (.max 30) (.with "email"))</pre>
<p>The node server example using the method chaining macro.</p>
<pre>(->
  (require "http")
  (.createServer
    (function (request response)
      (response.writeHead 200 {'Content-Type': 'text/plain'})
      (response.end "Hello World\n")))
  (.listen 3000 "127.0.0.1"))
</pre>

<h4>(var name1 value1 name2 value2 ...)</h4>
<p><code>var</code> allows you to create lexically scoped variables in the current scope.
This will compile to the JavaScript <code>var</code> statement so the variables will be hoisted.</p>
<pre>(var a 1 b 2)    =>  var a = 1,
                         b = 2;
</pre>

<h4>(str (string expression) ...)</h4>
<p>Adds up all the strings.</p>
<pre>(var title &quot;My Home Page&quot;)
(console.log
  (str &quot;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;&quot; title &quot;&lt;/title&gt;
&lt;/head&gt;
&lt;body class=\&quot;test\&quot;&gt;
Hello World
&lt;/body&gt;
&lt;/html&gt;&quot;))
</pre>
<p>In LispyScript double quoted strings are multiline strings. As you can see above they span multiple lines.
If you need a double quote inside the string, escape it with \".</p>

<h4>(array elem1 elem2 ....)</h4>
<p>Create a Javascript Array.</p>
<pre>(array 1 2 3 4)
</pre>
<p>You can also create an array using the Javascript literal notation like [1, 2, 3, 4] however there is a difference.
The literal notation is evaluated in the Javascript context, and will work in most cases except when you want some
LispyScript code evaluated, like when one of the elements is a LispyScript anonymous function. And unlike Javascript
"new Array" a single integer passed will still create a proper array with the int as the first element.</p>

<h4>(arrayInit length initialVal)</h4>
<p>Create a Javascript Array of length <code>length</code>, with all elements initialized 
to <code>initialVal</code></p>
<pre>(arrayInit 5 null)  =>  [null, null, null, null, null]
</pre>

<h4>(arrayInit2d outerLength innerLength initialVal)</h4>
<p>Create a Javascript Array of length <code>outerLength</code>, with all elements initialized 
to arrays of length <code>innerLength</code>, and all elements of inner arrays 
initialized to <code>initialVal</code></p>
<pre>(arrayInit2d 2 3 null)  =>  [[null, null, null], [null, null, null]
</pre>

<h4>(object key1 val1 key2 val2 ....)</h4>
<p>Create a Javascript Object.</p>
<pre>(object a 1 b 2 c 3) => {a: 1, b:2, c:3}
</pre>

<h4>(new Classname arg1 arg2 ....)</h4>
<p>Instantiate a new Javascript Object.</p>
<pre>(new Date)
(new Date "October 13, 1975 11:13:00")
</pre>

<h4>(if (condition) (if true expression) (if false expression))</h4>
<p>If takes a conditional expression and evaluates the true expression if the condition is true, or the false
expression otherwise.</p>

<h4>(cond (condition1) (expression1) (condition2) (expression2) ... (optional default expression))</h4>
<p>The cond statement (switch in Javascript) takes condition-expression pairs and an optional default expression.
The default expression is nothing but the last condition set to <code>true</code>.</p>
<pre>(cond
  (number? x) (console.log "numbers are ok")
  (string? x) (console.log "strings are ok")
  (boolean? x) (console.log "booleans are ok")
  true (console.log "This type is NOT ok"))
</pre>

<h4>(when (condition) (expression1) (expression2) ...)</h4>
<p>The when statement evaluates a set of expressions passed as it arguments when the condition is true.</p>

<h4>(unless (condition) (expression1) (expression2) ...)</h4>
<p>The unless statement evaluates a set of expressions passed as it arguments when the condition is false.</p>

<h4>(do (expression1) (expression2) ...)</h4>
<p>The do statement evaluates a set of expressions passed as it arguments.</p>

<h4>(function (arguments expression) (expression1) (expression2) ... )</h4>
<p>Creates an anonymous function.</p>

<h4>(try (expression1) (expression2) ... (catch function))</h4>
<p>Try takes a set of expressions and evaluates them. The last expression must be a function, that
will be called in case an exception is thrown. The function is called with the error object.</p>
<pre>(var fs (require 'fs'))
(var outfile &quot;text.txt&quot;)
(try
  (fs.writeFileSync outfile &quot;Hello World&quot;)
  (function (err)
    (console.log (+ &quot;Cannot write file &quot; outfile)
    (process.exit 1)))
</pre>
<h4>(include "string filename")</h4>
<p>Includes a file to be compiled with this compilation unit. It will also search the 'includes' folder for Lispyscript modules like 'html.ls'.</p>
<h4>(throw (expression))</h4>
<p>Will throw an error. (expression) can be string or object or an expression</p>
<h4>Comments</h4>
<p>Comments in LispyScript start with a <code>;</code> and span the rest of the line.</p>


<a name="looping"></a>
<h2 style="padding-top:40px">Iteration & Looping</h2>

<h4>(loop (arguments) (initial values) (expression1) (expression2) ...)</h4>
<p>The loop - recur construct is a tail call optimised looping expression. It creates a binding for
a set of arguments with a set of initial values. A recusion point is set by using a recur expression 
which passes control back to the top of the loop with a new set of bindings for the arguments.</p>
<pre>
(loop (result x) ([] 5)
  (if (= 0 x)
    result
    (do
      (result.push x)
      (recur result --x))))
</pre>
<p>The example above will return a countdown array starting from 5 "[5, 4, 3, 2, 1]"</p>
<p>Read more about loop recur and tail call optimization <a href="http://lispyscript.blogspot.in/2012/09/loop-recur-and-tail-call-optimization.html">here.</a></p>

<h4>(each array iterator [(context)])</h4>
<p><code>each</code> takes an array, an iterator function and an optional context.
  The iterator is called for each
element of the array with element value, index, array. If context is provided then "this" inside the 
iterator function will be the context object.</p>
<pre>(each [1, 2, 3]
  (function (elem index list)
    (console.log elem)))
</pre>

<h4>(each2d array iterator)</h4>
<p><code>each2d</code> takes an array whose elements are also arrays (2d array), and calls the
iterator function for each element. The iterator is called with the following arguments. 
<code>value</code> <code>innerIndex</code> <code>outerIndex</code>
<code>innerArray</code> <code>outerArray</code>.</p>

<h4>(eachKey object (iterator) [context])</h4>
<p><code>eachKey</code> iterates over a map (object) and calls the iterator with value, key, object respectively.</p>

<h4>(reduce array (iterator) [initial])</h4>
<p><code>reduce</code> takes an array, an iterator function and an optional initial value. The iterator is called
with the following paramaters, previous value returned by the last call to iterator, current value of array element, array index, and array. First time around the initial value is used for previous value. If no initial value is given, the previous value is set to the first element of the array and the iteration starts from the second element. The last value returned by the iterator is returned by reduce.</p>
<pre>(reduce [1,2,3,4]
  (function (accum val i list)
    (+ accum val))))
</pre>
<p>The above call to reduce will return 10.</p>

<h4>(map array (iterator) [(context)])</h4>
<p><code>map</code> takes an array, an iterator function and an optional context. The iterator is called for each
element of the array with element value, index, array. The returned value from the iterator for each call
is pushed into a new array. map returns the new array. If context is provided then "this" inside the 
iterator function will be the context object.</p>

<h4>(for (name1 array1 [name2 array2 ...] (result expression))</h4>
<p>In LispyScript <code>for</code> is a list comprehension expression. <code>for</code> does not work
like the JavaScript "for" statement.</p>
<pre>
(for
  (a [1,2,3] 
   b [3,4,5])
  (+ a b))

;; ==> [ 4, 5, 6, 5, 6, 7, 6, 7, 8 ]

;; we only want results that are &lt;= 6 below

(for
  (a [1,2,3]
   b [3,4,5])
  (when (&lt;= (+ a b) 6)
    (+ a b)))

;; ==> [ 4, 5, 6, 5, 6, 6 ]

(for 
  (letters ["a", "b", "c"]
   numbers [3, 4, 5])
  [letters, numbers])

;; ==> [['a',3],['a',4],['a',5],['b',3],['b',4],['b',5],['c',3],['c',4],['c',5]]
</pre>
<p>The bindings for <code>a</code> and <code>b</code> are made
for every element of the corresponding arrays. In the second example we applied a <code>when</code> condition
to the result expression to keep out results greater than six.</p>

<a name="macros"></a>        
<h2 style="padding-top:40px">Macros</h2>

<h4>(macro name (arguments expression) (template expression))</h4>
<p>LispyScript is not a dialect of Lisp. There is no list processing in LispyScript . LispyScript
is Javascript using a Lispy syntax (a tree syntax). This is so that we can manipulate the syntax tree
while compiling, in order to support macros.</p>
<p>You can define a macro.</p>
<pre>(macro array? (obj)
  (= (Object.prototype.toString.call ~obj) &quot;[object Array]&quot;))
</pre>

<p>The 'array?' conditional is defined as a macro in LispyScript. The 'macro' expression takes a name as
its second element, a parameters list in the third element, and the fourth element is the template
to which the macro will expand.</p>
<p>Now let us create a Lisp like 'let' macro in LispyScript.</p>
<pre>(macro let (names vals rest...)
  ((function ~names ~rest...) ~@vals))

(let (name email tel) (&quot;John&quot; &quot;john@example.org&quot; &quot;555-555-5555&quot;)
  (console.log name)
  (console.log email)
  (console.log tel))
</pre>

<p>The 'let' macro creates lexically scoped variables with initial values. It does this by creating
an anonymous function whose argument names are the required variable names, sets the variables to
their initial values by calling the function immediately with the values. The macro also wraps the
required code inside the function.</p>
<p>Now lets look at the call to the 'let' macro. 'names' will correspond to '(name email tel)'. 'rest...'
corresponds to '(console.log name) (console.log email) (console.log tel)', which is the rest of the
expressions after vals. We want to dereference these values in the macro template, and we do that
with '~names', '~rest...'. However 'vals' corresponds to ("John" "john@example.org" "555-555-5555").
But thats not the way we want to dereference it. We need to dereference it without the parenthesis.
For that we use '~@vals'.</p>
<p>We don't really need 'let' in LispyScript. We have 'var'. But if you need it, you can extend LispyScript
by adding this macro to your code. Thats the power of macros. You can
extend the language itself or create your own domain specific language.</p>


<a name="modules"></a>        
<h2 style="padding-top:40px">Modules</h2>

<p>You can write nodejs style modules in LispyScript and require them in LispyScript or JavaScript.</p>
<pre>
mymodule.ls
===========

(set module.exports
  (function (x) (* x x)))

main.js
=======

require("lispyscript/lib/require")
var square = require("./mymodule")
console.log(square(2))

</pre>


<a name="monads"></a>        
<h2 style="padding-top:40px">Monads</h2>
<p>Monads allow you to process data in steps. There are different types of monads, and each type provides you with
additional processing rules for each step. Fortunately you don't have to understand the workings of monads to use them.
LispyScript comes with four builtin monad types. The "identity monad", "maybe monad", "array monad" and 
"state monad". You can also write your own monads in LispyScript.</p>
<pre>;; using identity monad

(doMonad identityMonad
  (a 1 
   b (* a 2))
  (+ a b))
</pre>
<p>The expression above will return number 3. In general the domonad expression is written like below.</p>
<h4>(domonad name (varname1 expression1 varname2 expression2 ...) (result expression))</h4>
<p>Note that the variable <code>a</code> in step 1 is visible in step 2, and both <code>a</code> and
<code>b</code> are visible in the result expression.</p>
<pre>;; using maybe monad

(doMonad maybeMonad
  (a (task1) 
   b (task2))
  (doSomething))
</pre>
<p>The maybe monad is called so because may be it will do something. The way it works is that if any of the steps
returns <code>null</code> it will return <code>null</code> and not carry out the rest os the steps.</p>
<p>The array monad is a array comprehension.</p>
<pre>;; using array monad

(doMonad arrayMonad
  (a [1,2,3] 
   b [3,4,5])
  (+ a b))

;; ==> [ 4, 5, 6, 5, 6, 7, 6, 7, 8 ]

;; we only want results that are &lt;= 6 below

(doMonad arrayMonad
  (a [1,2,3]
   b [3,4,5])
  (when (&lt;= (+ a b) 6)
    (+ a b)))

;; ==> [ 4, 5, 6, 5, 6, 6 ]

(doMonad arrayMonad 
  (letters ["a", "b", "c"]
   numbers [3, 4, 5])
  [letters, numbers])

;; ==> [['a',3],['a',4],['a',5],['b',3],['b',4],['b',5],['c',3],['c',4],['c',5]]
</pre>
<p>The bindings for <code>a</code> and <code>b</code> are made
for every element of the corresponding arrays. In the second example we applied a <code>when</code> condition
to the result expression to keep out results greater than six. This <code>when</code> condition can only
be used with the array monad and maybe monad. Or to be more specific, monads that define <code>mZero</code></p>

<p>The state monad allows you to pass the current state through a set of steps. The state could be anything,
an integer, string, array, object etc. In the example below we will maintain state of an immutable stack
through a set of steps.</p>
<pre>;; First we write two functions push and pop,
;; which will be the operations we carry out.

;; push is a monadic function that accepts an element and returns a function.
;; The returned function accepts the current state (stack array),
;; creates a new state by creating a new array with the element
;; and concats the previous state to it. (we want an immutable state)
;; and returns a monadic value which is and array of two elements. The result
;; of the current operation (undefined) in this case and the new state.

(var push
  (function (element)
    (function (state)
      (var newstate [element])
      (array undefined (newstate.concat state)))))

;; In the same way above we write a pop function that will remove one
;; element from the stack and creates a new stack
;; and returns the popped value and the new stack.

(var pop
  (function ()
    (function (state)
      (var value (get 0 state))
      (var newstate (state.slice 1))
      (array value newstate))))

;; In the case of state monad domonad returns a function which we must call
;; with the initial state. We call the returned function stackOperation.

(var stackOperations 
  (doMonad stateMonad 
    (a (push 5) 
     b (push 10)
     c (push 20)
     d (pop))
    d))

(stackOperations [])

;; ==> [ 20, [ 10, 5 ] ]
</pre>
<h4>Writing your own monad</h4>
<p>To write monads use the <code>monad</code> expression. It takes two arguments. The name for the monad, and an
object of key value pairs. The keys <code>mResult</code> and <code>mBind</code> are obligatory. The values must be the
corresponding monadic result function and the monadic bind function. Optionally you can have the
<code>mZero</code> and <code>mPlus</code> keys with their corresponding values. The example below is the definition
of the identity monad.</p>
<pre>(monad identityMonad
  (object
    "mBind" (function (mv mf) (mf mv))
    "mResult" (function (v) v)))
</pre>
<p>LispyScript also supports the <code>withMonad</code> expression.</p>
<h4>(withMonad name (expression1) (expression2) ... )</h4>

<a name="templates"></a>
<h2 style="padding-top:40px">Templates</h2>

<h4>(template name (argument expression) (string expressions) ... )</h4>
<p>template takes a name and a list of arguments to be passed to the template as the second argument. The rest of the arguments are string expressions that make up the template. Template returns a compiled template function with the given name which you must call with the arguments to expand the template.</p>
<h4>(template-repeat (array expression) (string expressions) ... )</h4>
<p>template-repeat takes an array as its first argument and the rest are string expressions that form the template. The template is iterated over for every element of the array and the combined expanded template is returned. Within the template you can access the current element as 'elem' and the current index as 'index'.
Note that while 'template' returns a compiled template, 'template-repeat' returns the actual expanded string.</p>
<h4>(template-repeat-key (object expression) (string expressions) ... )</h4>
<p>template-repeat-key takes an object as its first argument and the rest are string expressions that form the template. The template is iterated over for every key value pair of the object and the combined expanded template is returned. Within the template you can access the current value as 'value' and the current key as 'key'.
Note that while 'template' returns a compiled template, 'template-repeat-key' returns the actual expanded string.</p>
<h4>HTML5 Templates</h4>
<p>Lispysript has a tree structure just like html, we can write html in our
templates in a Lispy manner. By including the 'html.ls' module you write
HTML Templates like below.</p>
<pre><code class="lisp">
(include &quot;html.ls&quot;)

(template page (title links)
  (html {lang:&quot;en&quot;}
    (head
      (title title)
      (script {type:&quot;text/javascript&quot;, src:&quot;js/test.js&quot;}))
    (body
      (div {class:&quot;navigation&quot;}
        (ul
          (template-repeat links 
            (li &quot;&lt;a href=\&quot;&quot; elem.href &quot;\&quot;&gt;&quot; elem.text &quot;&lt;/a&gt;&quot;))))
      (h1 &quot;HTML Templates&quot;)
      (p &quot;Welcome to LispyScript HTML templates!&quot;))))

(console.log
  (page
    &quot;My Home Page&quot;
    [{href:&quot;/about&quot;, text:&quot;About&quot;},
     {href:&quot;/products&quot;, text:&quot;Products&quot;},
     {href:&quot;/contact&quot;, text:&quot;Contact&quot;}]))

And below you can see the beautified html output.

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;title&gt;My Home Page&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;navigation&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/products&quot;&gt;Products&lt;/a&gt;
                &lt;/li&gt;
                &lt;li&gt;
                    &lt;a href=&quot;/contact&quot;&gt;Contact&lt;/a&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h1&gt;HTML Templates&lt;/h1&gt;
        &lt;p&gt;Welcome to LispyScript HTML templates!&lt;/p&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>

<a name="sequence"></a>
<h2 style="padding-top:40px">Callback Sequence</h2>
<p>LispyScript allows you to avoid writing nested callbacks, by a callback sequence feature. You write your callbacks
in a series (sequence). All the functions in the series are exposed to a functions called "next". Calling "next"
returns the next callback in the sequence. So just pass the return value of next, when you call a callback.
You can see an example with some notes on usage <a href="https://gist.github.com/3715526">here</a>.
</p>

<a name="testing"></a>
<h2 style="padding-top:40px">Testing</h2>

<p>LispyScript comes with some built in testing features to let you test your code while developing. However if
you find that the features offered in the built in tests are not enough, you can use any of the javascript
test frameworks available.</p>
<h4>(assert (expression) "string message")</h4>
<p>The expression must evaluate to "true" and not something truthy, and will return the message
with "Passed " or "Failed " added to your message. </p>
<h4>(testGroup name (assert1) (assert2) ...)</h4>
<p>Create test groups by calling the testGroup expression. It takes a name and one or more asserts. It creates a
testGroup which is invoked by the testRunner.</p>
<h4>(testRunner groupname "Desription")</h4>
<p>Call testRunner to invoke your test group. Pass it the name of the test group and a string description
which will be shown at the top of your test results. It returns the test results as a string.</p>
         
<a name="browserrunning"></a>
<h2 style="padding-top:40px">Running in Browser</h2>

<p>You can run LispyScript directly in the browser. However this will not be as fast a precompiling LispyScript on the server and loading the compiled JavaScript.</p>
<p>The examples folder has a browser example in the browser folder. Download the LispyScript project as a <a href="https://github.com/santoshrajan/lispyscript/archive/master.zip">zip file</a>. Extract the file and copy the "examples/browser" folder to a suitable location inside your server root. Browse to the path on your server. If all goes well you will see a number 4 alerted. Note that you can not open the index.html as a file, because LispyScript modules are loaded via XHR.</p>

<pre><code>
index.html
==========
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;title&gt;LispyScript Browser Example&lt;/title&gt;

  &lt;script type=&quot;text/javascript&quot; src=&quot;./js/browser-bundle.js&quot;&gt;&lt;/script&gt;

  &lt;script type=&quot;text/lispyscript&quot; id=&quot;macros&quot; src=&quot;./src/macros.ls&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/lispyscript&quot; id=&quot;square&quot; src=&quot;./src/square.ls&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/lispyscript&quot; id=&quot;main&quot;&gt;

(var square (require &quot;square&quot;))
(alert (square 2))

&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
      &lt;h1&gt;LispyScript Browser Example&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

square.ls
---------
(set module.exports (function (x)
  (* x x)))

</code></pre>

<ul>
  <li>Load the "./js/browser-bundle.js" in first.</li>
  <li>Load "./src/macros.ls". All LispyScript files must have type "text/lispyscript".</li>
  <li>Load your own ".ls" files. Each ".ls" file must have an id.</li>
  <li>Each LispyScript script tag is treated as a nodejs module. This is unlike JavaScript where every script is loaded in the global scope.</li>
  <li>The "id" is used to "require" the module in a subsequent module. In the example above we have one ".ls" file loaded ("square.ls"), and the last one is inline. The last module requires the "square" module.</li>
  <li>All modules are loaded and run on load. So you need to explicitly require a LispyScript module only if it exports something. This is unlike nodejs where you need to explicitly "require" every module. In the example above we don't "require" macros anywhere.</li>
  <li>Ideally you should give your modules the an "id" which is same as what the require statement on the server side would use. This is important so that the same module can be compiled on the server without any changes if required.</li>
</ul>
         
<a name="browser"></a>
<h2 style="padding-top:40px">Browser Compatibility</h2>

<p>LispyScript 0.3.0 and above only supports IE9 and above. For older browser support use LispyScript 0.2.9.</p>
<p>The compiled Javascript code is compatible with all modern browsers.</p>
<p>However since Lispyscript allows you to call Javascript functions directly from LispyScript,
you need to guard against calling non standard native functions. eg. If you call the Javascript "forEach" from
LispyScript, this will not work in IE8. So instead use LispyScript "each" instead.</p>
<p>You can also run LispyScript directly in your browser. Thats how the LispyScript tryit page works.
However this is not recommended, because compiling your LispyScript and loading the compiled Javascript will
always be faster.</p>

         
<a name="guidelines"></a>
<h2 style="padding-top:40px">Programming Guidelines</h2>

<ol>
  <li>You MUST use the "var" keyword when you create a variable. Otherwise this could lead to nasty surprises. This is
    also true of Javascript.</li>
  <li>Variable names starting with three underscores (___varname) are reserverd for LispyScript. You should not
    start a variable name with three underscores. Except in a special case which we will come to.</li>
  <li>Use macros with caution. In most cases a function would serve the purpose. In which case use a function.</li>
  <li>Write macros if you want to add new features to LispyScript or create a domain specific Language.</li>
  <li>And when you write macros be very careful when you create a variable inside your macro, either using var or as function argument names. Because if the arguments to your macro get dereferenced (eg. ~arg or ~rest...) in the same scope as the variables you created, there is chance for a variable capture situation. This happens when the user of your macro 
  has a variable with the same name and has used it in the argument passed to the macro.
  You can get around this in the following ways.
    <ul>
      <li>Obviously if your macro does not create any variables you are fine. There are many macros like that.</li>
      <li>If your macro is or has an immediately evaluated function, and the macro args get dereferenced as arguments
        to that function, you are fine again. Because the macro args get dereferenced outside the function. This is
        also a common situation in LispyScript. As far as possible try to get into this situation.</li>
      <li>If the variable you create needs to be accessed by the dereferenced code you are fine again</li>
      <li>If you still need to dereference the macro arg in the same scope as a variable created by you, then makes
        sure of two things. First that the variable you create is inside a function (usually the case), and second make sure the name starts with three underscores.</li>
    </ul>
</ol>

        </div>
      </div>
      <footer class="footer" style="margin-top: 45px; padding: 35px 0 36px;border-top: 1px solid #e5e5e5;">
        <p class="pull-right"><a href="#">Back to top</a></p>
        <p>Code licensed under the <a href="https://github.com/santoshrajan/lispyscript/blob/master/LICENSE" target="_blank">MIT License</a>. Documentation licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
        <p>Logo Icon from <a href="http://www.designcontest.com">DesignContest</a>, licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
      </footer>
    </div>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"
    type="text/javascript"></script>
    <script type="text/javascript" src="../bootstrap/js/bootstrap.js"></script>
  </body>

</html>
