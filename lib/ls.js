/*
 * 
LispyScript - Javascript using tree syntax!
 *
*/

var _ = require('underscore');

String.prototype.repeat = function(num) {
    return new Array(num + 1).join(this);
}

this.version = "0.1.0";
var _LS = {};
var banner = "// Generated by LispyScript v" + this.version + "\n";
var isWhitespace = /\s/;
var isFunction = /^function/;
var validName = /^[a-zA-Z_$][0-9a-zA-Z_$]*$/;
var noReturn = /^var|set|throw\b/;
var indent = -4;
var keywords = {};
var macros = {};
var templates = {};
templates["var"] = _.template("var <%= rest %>");
templates["set"] = _.template("<%= name %> = <%= value %>");
templates["function"] = _.template("function(<%= params %>) {\n<%= expressions %><%= indent %>}");
templates["try"] = _.template("(function () {try {\n<%= trypart %><%= indent %>} catch (err) {(<%= catchpart %>)(err)}})()");
templates["if"] = _.template("<%= condition %> ?\n<%= indent %><%= trueexpr %> \n<%= indent %>: <%= falseexpr %>");
templates["get"] = _.template("<%= list %>[<%= key %>]");
templates["operator"] = _.template("(<%= loperand %> <%= operator %> <%= roperand %>)");

var parse = function(code) {
//    if (/^\s*\(/.test(code) === false) throw handleError(0, 1);
    var code = "(" + code + ")";
    var length = code.length;
    var pos = 1;
    var lineno = 1;
    var parser = function() {
        var tree = [];
        tree._line = lineno;
        var token = "";
        var isString = false;
        var isSingleString = false;
        var isJSArray = 0;
        var isJSObject = 0;
        var isListComplete = false;
        var isComment = false;
        var handleToken = function() {
            if (token) {
                tree.push(token);
                token = "";
            };
        };
        while (pos < length) {
            var c = code.charAt(pos);
            pos++;
            if (c == "\n") {
                lineno++;
                if (isComment) isComment = false;
            };
            if (isComment) continue;
            if (c == '"') {
                isString = !isString;
                token += c;
                continue;
            };
            if (isString) {
                token += c;
                continue;
            };
            if (c == "'") {
                isSingleString = !isSingleString;
                token += c;
                continue;
            };
            if (isSingleString) {
                token += c;
                continue;
            };
            if (c == '[') {
                isJSArray++;
                token += c;
                continue;
            };
            if (c == ']') {
                if (isJSArray === 0) throw handleError(4, tree._line);
                isJSArray--;
                token += c;
                continue;
            };
            if (isJSArray) {
                token += c;
                continue;
            };
            if (c == '{') {
                isJSObject++;
                token += c;
                continue;
            };
            if (c == '}') {
                if (isJSObject === 0) throw handleError(6, tree._line);
                isJSObject--;
                token += c;
                continue;
            };
            if (isJSObject) {
                token += c;
                continue;
            };
            if (c == "#") {
                isComment = true;
                continue;
            };
            if (c == "(") {
                tree.push(parser());
                continue;
            };
            if (c == ")") {
                isListComplete = true;
                handleToken();
                break;
            };
            if (isWhitespace.test(c)) {
                handleToken();
                continue;
            };
            token += c;
        };
        if (isString) throw handleError(3, tree._line);
        if (isSingleString) throw handleError(3, tree._line);
        if (isJSArray > 0) throw handleError(5, tree._line);
        if (isJSObject > 0) throw handleError(7, tree._line);
        if (!isListComplete) throw handleError(8, tree._line);
        return tree;
    };
    var ret = parser();
    if (pos < length) throw handleError(10, "end");
    return ret;
};

var handleExpressions = function(exprs) {
    indent += 4;
    var ret = "", l = exprs.length, indentstr = " ".repeat(indent);
    _.each(exprs, function(expr, i, exprs) {
        var tmp, r = "";
        if (_.isArray(expr))
            tmp = handleExpression(expr);
        else
            tmp = expr;
        if (i === l - 1 && indent) 
            if (!noReturn.test(tmp)) r = "return ";
        if (tmp.length > 0)
            ret += indentstr + r + tmp + ";\n";
    });
    indent -= 4;
    return ret;
};

var handleExpression = function(expr) {
    var command = expr[0];
    if (macros[command]) {
        expr = macroExpand(expr);
        return handleExpression(expr);
    }
    if (keywords[command])
        return keywords[command](expr);
    handleSubExpressions(expr);
    var fName = expr[0];
    if (!fName) throw handleError(1, expr._line);
    if (isFunction.test(fName)) fName = "(" + fName + ")";
    return fName + "(" + expr.slice(1).join(",") + ")";
    
};

var handleSubExpressions = function(expr) {
    _.each(expr, function(value, i, t) {
        if (_.isArray(value)) t[i] = handleExpression(value);
    });    
};

var macroExpand = function(tree) {
    var command = tree[0];
    var template = macros[command]["template"];
    var code = macros[command]["code"];
    var replacements = {};
    for (var i = 0; i < template.length; i++) {
        if (template[i] == "rest...") {
            replacements["~rest..."] = tree.slice(i + 1);
        } else {
            replacements["~" + template[i]] = tree[i + 1];
        }
    }
    var replaceCode = function(source) {
        var ret = [];
        ret._line = tree._line;
        for (var i = 0; i < source.length; i++) {
            if (typeof source[i] == "object") {
                ret.push(replaceCode(source[i]));
            } else {
                var token = source[i];
                var isATSign = false;
                if (token.indexOf("@") >= 0) {
                    isATSign = true;
                    token = token.replace("@", "") ;
                }
                if (replacements[token]) {
                    var repl = replacements[token];
                    if (isATSign || token == "~rest...") {
                        for (var i = 0; i < repl.length; i++)
                            ret.push(repl[i]);
                    } else {
                        ret.push(repl);
                    }
                } else {                    
                    ret.push(token);
                }
            }
        }
        return ret;
    }
    return replaceCode(code);
};

var handleOperator = function(arr) {
    if (arr.length != 3)  throw handleError(0, arr._line);
    handleSubExpressions(arr);
    if (arr[0] == "=") arr[0] = "===";
    if (arr[0] == "!=") arr[0] = "!==";
    return templates["operator"]({operator: arr[0], loperand: arr[1], roperand: arr[2]});
};

var handleError = function(no, line) {
    return errors[no] + ", line no " + line;
}

keywords["var"] = function(arr) {
    if (!validName.test(arr[1])) throw handleError(9, arr._line);
    return templates["var"]({rest: keywords.set(arr)});
};

keywords["set"] = function(arr) {
    if (arr.length != 3) throw handleError(0, arr._line);
    return templates["set"]({
        name: arr[1],
        value: (typeof arr[2] == "object") ? handleExpression(arr[2]) : arr[2]});
}

keywords["function"] = function(arr) {
    if (arr.length < 3) throw handleError(0, arr._line);
    if (typeof arr[1] != "object") throw handleError(0, arr._line);
    return templates["function"]({
        params: arr[1].join(","),
        expressions: handleExpressions(arr.slice(2)),
        indent: " ".repeat(indent)});
}

keywords["try"] = function(arr) {
    if (arr.length < 3) throw handleError(0, arr._line);
    var c = arr.pop();
    return templates["try"]({
        trypart: handleExpressions(arr.slice(1)),
        catchpart: handleExpression(c),
        indent: " ".repeat(indent)});
}

keywords["if"] = function(arr) {
    if (arr.length < 3 || arr.length > 4)  throw handleError(0, arr._line);
    indent += 4;
    handleSubExpressions(arr);
    var ret = templates["if"]({
        condition: arr[1],
        trueexpr: arr[2],
        falseexpr: arr[3],
        indent: " ".repeat(indent)});
    indent -= 4;
    return ret;
}


keywords["get"] = function(arr) {
    if (arr.length != 3) throw handleError(0, arr._line);
    return templates["get"]({key: arr[1], list: arr[2]});
};

keywords["macro"] = function(arr) {
    if (arr.length != 4)  throw handleError(0, arr._line);
    macros[arr[1]] = {template: arr[2], code: arr[3]};
    return "";
}

keywords["+"] = handleOperator;

keywords["-"] = handleOperator;

keywords["*"] = handleOperator;

keywords["/"] = handleOperator;

keywords["%"] = handleOperator;

keywords["="] = handleOperator;

keywords["!="] = handleOperator;

keywords[">"] = handleOperator;

keywords[">="] = handleOperator;

keywords["<"] = handleOperator;

keywords["<="] = handleOperator;

keywords["||"] = handleOperator;

keywords["&&"] = handleOperator;

keywords["!"] = function(arr) {
    if (arr.length != 2)  throw handleError(0, arr._line);
    handleSubExpressions(arr);
    return "(!" + arr[1] + ")";
}

errors = [];
errors[0] = "Syntax Error";
errors[1] = "Empty statement";
errors[2] = "Invalid characters in function name";
errors[3] = "End of File encountered, unterminated string";
errors[4] = "Closing square bracket, without an opening square bracket";
errors[5] = "End of File encountered, unterminated array";
errors[6] = "Closing curly brace, without an opening curly brace";
errors[7] = "End of File encountered, unterminated javascript object '}'";
errors[8] = "End of File encountered, unterminated parenthesis";
errors[9] = "Invalid character in var name";
errors[10] = "Extra chars at end of file. Maybe an extra ')'.";

this._compile = function(code) {
  var tree = parse(code);
  var gen = handleExpressions(tree);
  return banner + gen;
}
